铁路图
	-> 从左边界到右边界
	-> 圆框中遇到的是字面量，在方块中遇到的是规则和描述

for 语句
	-> 常见形式由三个可选从句控制：初始化从句、条件从句和增量从句
	-> for in语句
	-> Object.hasOwnProperty(variable)确定属性名是否是该对象的成员

Javascript中不允许return语句与表达式之间换行
Javascript中不允许break语句与表达式之间换行

typeof产生的值有'number', 'string' , 'boolean' , 'undefined' , 'function'和'object' ，如果是数组或null，则是'object'。

javascript中对象是可变的键控集合
	-> 对象是属性的集合
	-> js中对象是无类别的，他对新属性的名字和值没有约束。对象适合用于收集和管理数据。
	-> ||可以用来填充默认值，例如：var middle = stoog["middle-name"] || "(none)"
	-> 对象通过引用来传递，它们永远不会被拷贝
	-> 我们尝试从某对象获取属性，且该对象没有该属性名，那么js会试着从原型对象中查找，如果也没有，则会从它的原型对象的原型中寻找，以此类推，这个过程最后达到Object.prototype。如果属性不存在原型链中，那么结果是undefined。这个过程称为委托

函数
	-> 所谓编程就是将一组需求分解为一组函数与数据结构的技能
	-> 闭包：通过函数字面量创建的函数对象包含一个连到外部上下文的链接。这是js强大表现力的根基。
	-> 每个函数接收两个附加参数：this和arguments。参数this在面向对象中非常重要，它的值取决于调用的模式。
	-> js中一共有四种调用模式：方法调用模式，函数调用模式，构造器调用模式和apply调用模式。
	这些模式在如何初始化this上存在差异。
		-> 方法调用模式：当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this被绑定为该对象。this到对象绑定发生在调用的时候。这个“超级”迟的绑定使得函数对this的高度复用。通过this可取得他们所属对象的上下文的方法称为公共方法。
		-> 函数调用模式：当一个函数并非一个对象的属性时，那么它被当做一个函数来调用，当函数被调用时，this被绑定到全局对象。这是语言设计上的一个错误。倘若语言设计正确，当内部函数被调用时，this应该仍然绑定到外部函数的this变量。这个设计错误的后果是方法不能利用内部函数来帮帮助它工作，因为内部函数的this值被绑定了错误的值，所以不能共享该方法对对象的访问权。
			解决方法：
				myObject.double = function () {
					var that = this;
					var helper = function () {
						that.value = add(that.value,that.value);
					};
					helper();
				}
		-> 构造器调用模式： js是一门基于原型继承的语言。这意味着对象可以直接从其他对象继承属性。该语言是无类别的。如果在一个函数前面带上new来调用，那么将创建一个隐藏链接到该函数的prototype成员的新对象，同时this将会被绑定到那个新对象上。new前缀也会改变return语句的行为。目的就是结合new前缀调用的函数被称为构造器函数。
		-> apply调用模式：js是一门函数式的面向对象的编程语言，所以函数可拥有方法。
			apply方法让我们构建一个参数数组并用其去调用方法。他也允许我们选择this的值。它接收两个参数，第一个参数被绑定给this的值。第二个是一个参数数组。
	-> 参数：当函数被调用时，会得到一个“免费”奉送的参数，那就是arguments数组。通过它可以访问所有它被调用时传递给他的参数列表。

作用域
	-> 在编程语言中，作用域控制着变量与参数的可见性及生命周期。它减少了名称冲突，并且提供了自动内存管理。

闭包
	-> 闭包：该函数可以访问它被创建时所处的上下文环境。