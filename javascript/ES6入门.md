# ECMAScript6 #

## let和const应用 ##

### let ###
* ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。

* let语句不存在变量提升

* 暂时性死区：
	* 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

	* ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

	`var tmp = 123;
	if (true) {
  		tmp = 'abc'; // ReferenceError
 		let tmp;
	}`

	* “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。

	* “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。在let定义的变量之前使用typeof判断该变量的类型会导致错误。

* for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。

* 不允许重复声明：let不允许在相同作用域内，重复声明同一个变量。

* let实际上为 JavaScript 新增了块级作用域。

* ES6 允许块级作用域的任意嵌套。外层作用域无法读取内层作用域的变量。内层作用域可以读取外层作用域的变量（跟函数的闭包实现的块级作用域一样）。内层作用域可以定义外层作用域的同名变量。

* 块级作用域与函数声明：
	* ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明（浏览器未实现，但是在严格模式下不允许）。
	
	* ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。（浏览器可以不遵守上述规则）

	* 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
	
	* 还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。

