代码书写规则
    1.最小的全局变量
    2.在某些情况，当window不能用，访问全局变量
        var global = (function ( ) {
            return this;
        })()
    3.单var形式(写在顶部)
        好处: 1.提供了一个单一的地方去寻找功能所需要的所有局部变量
            2.防止变量在定义之前使用的逻辑错误
            3.帮助你记住声明的全局变量，因此较少了全局变量
            4.少代码（类型啊传值啊单线完成）
    4.for循环
        1.缓存数组(集合)的长度
        2.i++替换成i=i+1或i+=1；
        3.向下到0，因为和0比较会快一些
    5.不扩展内置原型
    6.switch模式
        每个case和switch对齐（花括号缩进规则除外）
        每个case中代码缩进
        每个case以break清除结束
        避免贯穿（故意忽略break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的。
        以default结束switch：确保总有健全的结果，即使无情况匹配。
    7.避免隐式类型装换
        为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。
    8.避免eval()
        同样重要的是要记住，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。
        使用新的Function()构造就类似于eval()，应小心接近。这可能是一个强大的构造，但往往被误用。如果你绝对必须使用eval()，你 可以考虑使用new Function()代替。有一个小的潜在好处，因为在新Function()中作代码评估是在局部函数作用域中运行，所以代码中任何被评估的通过var 定义的变量都不会自动变成全局变量。另一种方法来阻止自动全局变量是封装eval()调用到一个即时函数中。
        另一间eval()和Function构造不同的是eval()可以干扰作用域链，而Function()更安分守己些。不管你在哪里执行 Function()，它只看到全局作用域。所以其能很好的避免本地变量污染。
    9.使用parseInt需要制定基数参数
        当字符串以”0″开头的时候就有可能会出问 题，例如，部分时间进入表单域，在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。


揭秘函数表达式
    1.在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval('(' + json + ')')，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。

    2.函数声明只能出现在程序或函数体内。从句法上讲，它们不能出现在Block（块）（{ ... }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块）中只能包含Statement语句， 而不能包含函数声明这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让表达式出现在Block（块）中情形，就是让它作为表达式语句的一部分。但是，规范明确规定了表达式语句不能以关键字function开头。而这实际上就是说，函数表达式同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。 

    3.var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效

    4.JScript的bug(ie)
        函数表达式的标示符泄露到外部作用域(IE9貌似已经修复了这个问题)
            var f = function g(){};
            typeof g; // "function"

        命名函数表达式会创建两个截然不同的函数对象！
            var f = function g(){};
            f === g; // false

            f.expando = 'foo';
            g.expando; // undefined

        仅仅顺序解析函数声明而忽略条件语句块
            var f = function g() {
            return 1;
            };
            if (false) {
            f = function g(){
                return 2;
            };
            }
            g(); // 2

js核心
    函数表达式[function expression]（而不是函数声明[function declarations，区别请参考本系列第2章]）是不包含在VO[variable object]（变量对象）里面的。

    闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。

    请注意，因为每一个普通函数在创建时保存了[[Scope]]，理论上，ECMAScript中所有函数都是闭包。

    this是执行上下文环境的一个属性，而不是某个变量对象的属性

    Firebug同样是使用eval来执行控制台里你的代码。因此，变量属性同样没有{DontDelete}特性，可以被删除。


This
    调用函数的方式影响了调用的上下文中的this值，没有别的什么

    在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。注：第5版的ECMAScript中，已经不强迫转换成全局变量了，而是赋值为undefined。